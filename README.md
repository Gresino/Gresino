# Gresino

Gresino is a patch-scheduling algorithm for automated program repair (APR) that aims to improve the efficiency of APR tools.
The patch space is large and it takes long to build and test each patched program.
Gresino detects more valid patches by using grey-box algorithm.

## Environments & Setup

### Environment
- Python >= 3.8
- JDK 1.8
- [Defects4j](https://github.com/rjust/defects4j) 1.2.0
- Maven

### Preparing the patch space

Gresino takes as input the patch space to explore and the patch-scheduling algorithm to use. Regarding the patch space, Gresino currently provides an option to use the patch space of one of the following 8 program repair tools:

1. ```Tbar```
2. ```Avatar```
3. ```kPar```
4. ```Fixminer```
5. ```AlphaRepair```
6. ```Recoder```
7. ```SRepair```
8. ```SelfAPR```

To construct the patch space provided by one of the above tools, see the README file for the tool. For example, the README file of ```Tbar``` is available at [TBar/README.md](TBar/README.md). We also provide a Python script that automates patch-space preparation. See [experiments](./experiments/).


### Setting up Gresino
Gresino is implemented in Python3. Gresino is in the [Gresino](./Gresino/) directory. To set up Gresino, do the following:
```
$ cd Gresino
$ python3 -m pip install -r requirements.txt
```

## How to reproduce our experiment
All reproduction scripts and their descriptions are available in the [experiments](./experiments/) directory.



## Running Gresino
The implementation of Gresino is available in the [Gresino](./Gresino) directory. To run Gresino, do the following:
```
$ cd Gresino
$ python3 gresino.py [options] -- {test_command}
```
More details are available in [Gresino](./Gresino/README.md).

### Running Gresino via Docker
To run Gresino via Docker, install 
- [docker](https://www.docker.com/)

Plus, you should install the following to utilize GPU for learning-based tools.
- [NVIDIA driver](https://www.nvidia.com/download/index.aspx)
- [nvidia-docker](https://github.com/NVIDIA/nvidia-docker)

Then, build the docker image with the Dockerfile.
```
$ docker build -t gresino .
```

## How to add a new APR tool
We already integrated eight APR tools into Gresino.

To add a new APR tool, please store the APR tool into `Gresino/` and modify it to add the following two features.

### Storing every patch candidates
A new APR tool has to store every patch candidates instead of performing patch validation.
Store **patched source file** in `<APR tool>/d4j/<bug id>`.

For example, for TBar with Chart_26 in Defects4j, our modified TBar stores every patch candidates in `Gresino/TBar/d4j/Chart_26`.
In the directory, each directory represents patch candidates.

### Meta-information file
A new APR tool has to generate a JSON file that contains information about patch candidates and the bug.
Please store the JSON file that follows the format described below in `<APR tool>/d4j/<bug id>/switch-info.json`.
For example, for TBar with Chart_26, stores it in `Gresino/Tbar/d4j/Chart_26/switch-info.json`.

It should follow the format described below:
```
{
  "project_name": <bug id>,
  "priority": [  // FL result
    {
      "file": <suspicious file>,
      "line": <suspicious line>,
      "score": <score from FL reuslt>
    },
    ...
  ],
  "failing_test_cases": [ // tests failed in buggy version and had to repair
    <failing test 1>,
    <failing test 2>,
    ...
  ],
  "passing_test_cases": [ // tests passed in buggy version
    <passing test 1>,
    <passing test 2>,
    ...
  ],
  "failed_passing_tests": [ // tests failed in fixed version
    <failed_passing_test 1>,
    ...
  ],
  "ranking": [ // patch ranking generated by original APR tool
    <patch id 1>,
    <patch id 2>,
    ...
  ],
  "rules": [  // patch space tree, described in below
  ]
}
```

- `"project_name"`: ID of the bug such as `"Chart_26"`.
- `"priority"`: FL result from FL tool. It contains suspicious file, line and FL score generated by FL tool.
- `"failing_test_cases"`: Tests that failed in buggy version but passed in fixed version. Follow the format used in Defects4j with test method. For Chart_26, `"org.jfree.chart.junit.AreaChartTests::testDrawWithNullInfo"`.
- `"passing_test_cases"`: Tests that passed in both buggy and fixed version. Follow the format used in Defects4j without test method. For chart_26, `"org.jfree.chart.annotations.junit.AnnotationsPackageTests"`.
- `"failed_passing_tests"`: Tests that failed in both buggy and fixed version because of the another reason such as environment. Follow same format with `failing_test_cases`. For Chart_26, the list is empty.
- `"ranking"`: Patch ranking generated by original APR tool. It used by SimAPR to perform original scheduling algorithm. `<patch id>` is described below.
- `"rules"`: Patch space tree structure described in our paper. Described in below.

Here, the `<patch ID>` is the path to the patched source file stored under `<APR tool>/d4j/<bug id>`.
For example, if the patch candidate stored in `Gresino/TBar/d4j/Chart_26/0/MethodInvocationMutator/1/CategoryPlot.java`, `<patch ID>` will be `0/MethodInvocationMutator/1/CategoryPlot.java`.

A structure of `"rules"` is slightly different between template-based and learning-based APR tools.

First, let's see for template-based tools.
```
"rules": [
  {
    "file_name": <path to source file>,
    "class_name": <patch to class file>,
    "functions": [
      {
        "function": <description of method>,
        "lines": [
          {
            "line": <patched line>,
            "fl_score": <suspicioud score from FL result>,
            "cases": [
              {
                "mutation": <template used to generate this patch candidate>,
                "location": <patch id>
              },
              ...
            ]
          },
          ...
        ]
      },
      ...
    ]
  },
  ...
```

- `"file_name"`: A path to patched source file in project directory. For Chart_26, `source/org/jfree/chart/plot/CategoryPlot.java`.
- `"class_name"`: A patch to patched class file in project directory. For Chart_26, `build/org/jfree/chart/plot/CategoryPlot.class`.
- `"function"`: Description of the patched method. If the patch candidate is not in the method, it should be seperated. For Chart_26, `draw[Graphics2D g2,Rectangle2D area,Point2D anchor,PlotState parentState,PlotRenderingInfo state]`.
- `"line"`: Patched line. It should be in FL result.
- `"fl_score"`: Suspicious score for this file and line generated by FL tool.
- `"mutation"`: Template used to generate each patch candidate. For TBar with Chart_26, `MethodInvocationMutator`.
- `"location"`: Patch ID. Patch ID is the path to the stored patched file under `<APR tool>/d4j/<bug id>`. For TBar and Chart_26, `0/MethodInvocationMutator/1/CategoryPlot.java`. Patch ID is also used in `"ranking"`.

Next, let's see for learning-based tools.
```
"cases": [
  {
    "prob": <patch score generated by language model (optional)>,
    "location": <patch id>
  },
  ...
]
```
For learning-based tools, it does not use template to generate patch candidates. Instead, a tool may generate **patch score**.

`"prob"` is optional because some language model may not generate any score. In this case, SimAPR may initialize `"prob"` to 0.5 for every patch candidates.
